name: CI - Build Linux & Windows

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
    env:
      CARGO_TERM_COLOR: always
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache Cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          components: clippy, rustfmt
          override: true

      - name: Install dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y qt6-base-dev qt6-declarative-dev cmake ninja-build pkg-config
          # Ensure qmake/rcc executables are exported for `cxx-qt-build`
          if command -v qmake-qt6 >/dev/null 2>&1; then echo "QT_QMAKE_EXECUTABLE=$(which qmake-qt6)" >> $GITHUB_ENV; elif command -v qmake >/dev/null 2>&1; then echo "QT_QMAKE_EXECUTABLE=$(which qmake)" >> $GITHUB_ENV; fi
          if command -v rcc >/dev/null 2>&1; then echo "QT_RCC_EXECUTABLE=$(which rcc)" >> $GITHUB_ENV; elif command -v rcc-qt6 >/dev/null 2>&1; then echo "QT_RCC_EXECUTABLE=$(which rcc-qt6)" >> $GITHUB_ENV; fi

      - name: Install Qt (Windows)
        if: runner.os == 'Windows'
        uses: jurplel/install-qt-action@v3
        with:
          version: '6.6.3'
          arch: 'win64_msvc2019_64'

      - name: Set QT env variables (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Prefer a command lookup first (should be in PATH after setup-qt), otherwise attempt to probe common install locations
          $qmake = (Get-Command qmake.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source) -ne $null ? (Get-Command qmake.exe -ErrorAction SilentlyContinue).Source : $null
          if (-not $qmake) {
            # Common locations where setup-qt installs may put qmake
            $possible = @('C:\Qt', 'C:\HostedToolCache\windows\Qt')
            foreach ($p in $possible) {
              $found = Get-ChildItem $p -Directory -ErrorAction SilentlyContinue | ForEach-Object { Get-ChildItem $_.FullName -Directory -ErrorAction SilentlyContinue } | ForEach-Object { Get-ChildItem ($_ | Select-Object -ExpandProperty FullName) -Filter 'qmake.exe' -Recurse -ErrorAction SilentlyContinue } | Select-Object -First 1
              if ($found) { $qmake = $found.FullName; break }
            }
          }
          $rcc = (Get-Command rcc.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source) -ne $null ? (Get-Command rcc.exe -ErrorAction SilentlyContinue).Source : $null
          if (-not $rcc) {
            $rcc = (Get-Command qt6-rcc.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source) -ne $null ? (Get-Command qt6-rcc.exe -ErrorAction SilentlyContinue).Source : $null
          }
          if (-not $qmake -or -not $rcc) {
            Write-Host "Warning: qmake or rcc not found in PATH. qmake=$qmake rcc=$rcc"
          }
          # Resolve bin directory and set env vars used by build.rs (cxx-qt-build)
          if ($qmake) {
            $qtBin = Split-Path -Path $qmake -Parent
            Add-Content -Path $env:GITHUB_ENV -Value "QT_BIN=$qtBin"
            Add-Content -Path $env:GITHUB_ENV -Value "QT_QMAKE_EXECUTABLE=$qmake"
          }
          if ($rcc) { Add-Content -Path $env:GITHUB_ENV -Value "QT_RCC_EXECUTABLE=$rcc" }
          if ($qtBin) { $env:PATH = "$qtBin;$env:PATH" }

      - name: Setup MSVC (Windows)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1

      - name: Ensure build tools (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Visual Studio & MSVC are preinstalled on windows-latest; make sure cl is available
          cl.exe /?

      - name: Set QT env variables (Linux fallback)
        if: runner.os == 'Linux'
        run: |
          # Debug output of QT variables
          echo "QT_QMAKE_EXECUTABLE=$QT_QMAKE_EXECUTABLE"
          echo "QT_RCC_EXECUTABLE=$QT_RCC_EXECUTABLE"

      - name: Build (release)
        run: |
          # On Windows this uses MSVC toolchain; on Linux the system gcc toolchain
          cargo build --release

      - name: Package (Linux)
        if: runner.os == 'Linux'
        run: |
          mkdir -p artifact
          cp target/release/supervtf artifact/
          # Include QML + media resources (app expects them at runtime)
          cp -r qml media resources.qrc artifact/ || true
          tar -czf supervtf-linux.tar.gz -C artifact .

      - name: Package (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Install UPX for compression
          choco install upx -y

          $exe = "target\release\supervtf.exe"
          $QtBin = $env:QT_BIN
          if (-not $QtBin -or -not (Test-Path $QtBin)) {
            $qmakePath = (Get-Command qmake.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source) -ne $null ? (Get-Command qmake.exe -ErrorAction SilentlyContinue).Source : $null
            if ($qmakePath) { $QtBin = Split-Path -Path $qmakePath -Parent }
          }
          if (-not (Test-Path $exe)) { throw "Executable not found: $exe" }
          
          # Use windeployqt to gather required Qt DLLs
          $windeploy = (Get-Command windeployqt.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source) -ne $null ? (Get-Command windeployqt.exe -ErrorAction SilentlyContinue).Source : "$QtBin\windeployqt.exe"
          if (-not (Test-Path $windeploy)) { 
            Write-Host "windeployqt not found: $windeploy" 
          } else { 
            # Exclude translations and other extras to save space
            # Added --qmldir qml so windeployqt scans imports and copies QtQuick/Controls modules
            & $windeploy --dir artifact --qmldir qml --no-translations --no-compiler-runtime --no-system-d3d-compiler --no-opengl-sw $exe 
          }
          
          # Copy the main executable
          Copy-Item $exe -Destination artifact
          
          # Remove heavy files if they exist (software rasterizer is often 20MB+)
          if (Test-Path "artifact\opengl32sw.dll") { Remove-Item "artifact\opengl32sw.dll" }
          
          # Compress EXE and DLLs with UPX
          Get-ChildItem artifact -Include *.exe,*.dll -Recurse | ForEach-Object {
            Write-Host "Compressing $($_.Name)..."
            upx --best --lzma $_.FullName
          }

          # Create SFX (Single Executable)
          # 1. Create 7z archive of the artifact folder content
          # 2. Concatenate 7z SDX module + config + archive
          
          $7zPath = "C:\Program Files\7-Zip\7z.exe"
          $sfxModule = "C:\Program Files\7-Zip\7z.sfx"
          
          if (-not (Test-Path $7zPath)) { 
            # Fallback if 7-Zip not in standard location, try choco install
            choco install 7zip -y
            $7zPath = "C:\Program Files\7-Zip\7z.exe"
            $sfxModule = "C:\Program Files\7-Zip\7z.sfx"
          }

          # Create the 7z archive (high compression)
          & $7zPath a -mx9 -t7z payload.7z ".\artifact\*"
          
          # Create SFX config
          $config = @"
          ;!@Install@!UTF-8!
          Title="SuperVTF"
          ExecuteFile="supervtf.exe"
          ;!@InstallEnd@!
          "@
          Set-Content -Path config.txt -Value $config -Encoding UTF8
          
          # Combine to create the single EXE
          # cmd /c copy /b 7z.sfx + config.txt + payload.7z supervtf-portable.exe
          cmd /c "copy /b `"$sfxModule`" + config.txt + payload.7z supervtf-portable.exe"
          
          # Upload the single EXE
          Copy-Item supervtf-portable.exe -Destination .

      - name: Upload artifact (Linux)
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: supervtf-linux
          path: supervtf-linux.tar.gz

      - name: Upload artifact (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: supervtf-windows-portable
          path: supervtf-portable.exe
