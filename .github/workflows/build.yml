name: CI - Build Linux & Windows

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
    env:
      CARGO_TERM_COLOR: always
      CARGO_INCREMENTAL: 0
      # REMOVED: "-C target-cpu=native" to ensure the app runs on all user computers, not just the CI runner.
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      # RECOMMENDED: Use Swatinem/rust-cache instead of manual caching or sccache
      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2

      - name: Install dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y qt6-base-dev qt6-declarative-dev cmake ninja-build pkg-config
          # Ensure qmake/rcc executables are exported for `cxx-qt-build`
          if command -v qmake-qt6 >/dev/null 2>&1; then echo "QT_QMAKE_EXECUTABLE=$(which qmake-qt6)" >> $GITHUB_ENV; elif command -v qmake >/dev/null 2>&1; then echo "QT_QMAKE_EXECUTABLE=$(which qmake)" >> $GITHUB_ENV; fi
          if command -v rcc >/dev/null 2>&1; then echo "QT_RCC_EXECUTABLE=$(which rcc)" >> $GITHUB_ENV; elif command -v rcc-qt6 >/dev/null 2>&1; then echo "QT_RCC_EXECUTABLE=$(which rcc-qt6)" >> $GITHUB_ENV; fi

      - name: Install Qt (Windows)
        if: runner.os == 'Windows'
        uses: jurplel/install-qt-action@v3
        with:
          version: '6.6.3'
          arch: 'win64_msvc2019_64'

      - name: Set QT env variables (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Prefer a command lookup first (should be in PATH after setup-qt), otherwise attempt to probe common install locations
          $qmake = (Get-Command qmake.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source) -ne $null ? (Get-Command qmake.exe -ErrorAction SilentlyContinue).Source : $null
          if (-not $qmake) {
            # Common locations where setup-qt installs may put qmake
            $possible = @('C:\Qt', 'C:\HostedToolCache\windows\Qt')
            foreach ($p in $possible) {
              $found = Get-ChildItem $p -Directory -ErrorAction SilentlyContinue | ForEach-Object { Get-ChildItem $_.FullName -Directory -ErrorAction SilentlyContinue } | ForEach-Object { Get-ChildItem ($_ | Select-Object -ExpandProperty FullName) -Filter 'qmake.exe' -Recurse -ErrorAction SilentlyContinue } | Select-Object -First 1
              if ($found) { $qmake = $found.FullName; break }
            }
          }
          $rcc = (Get-Command rcc.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source) -ne $null ? (Get-Command rcc.exe -ErrorAction SilentlyContinue).Source : $null
          if (-not $rcc) {
            $rcc = (Get-Command qt6-rcc.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source) -ne $null ? (Get-Command qt6-rcc.exe -ErrorAction SilentlyContinue).Source : $null
          }
          if (-not $qmake -or -not $rcc) {
            Write-Host "Warning: qmake or rcc not found in PATH. qmake=$qmake rcc=$rcc"
          }
          # Resolve bin directory and set env vars used by build.rs (cxx-qt-build)
          if ($qmake) {
            $qtBin = Split-Path -Path $qmake -Parent
            Add-Content -Path $env:GITHUB_ENV -Value "QT_BIN=$qtBin"
            Add-Content -Path $env:GITHUB_ENV -Value "QT_QMAKE_EXECUTABLE=$qmake"
          }
          if ($rcc) { Add-Content -Path $env:GITHUB_ENV -Value "QT_RCC_EXECUTABLE=$rcc" }
          if ($qtBin) { $env:PATH = "$qtBin;$env:PATH" }

      - name: Setup MSVC (Windows)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1

      - name: Ensure build tools (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Visual Studio & MSVC are preinstalled on windows-latest; make sure cl is available
          cl.exe /?

      - name: Set QT env variables (Linux fallback)
        if: runner.os == 'Linux'
        run: |
          # Debug output of QT variables
          echo "QT_QMAKE_EXECUTABLE=$QT_QMAKE_EXECUTABLE"
          echo "QT_RCC_EXECUTABLE=$QT_RCC_EXECUTABLE"

      - name: Build (release)
        run: cargo build --release

      - name: Package (Linux)
        if: runner.os == 'Linux'
        run: |
          # Install tools for creating self-extracting archive (pixz for parallel xz)
          sudo apt-get install -y p7zip-full upx-ucl pixz

          mkdir -p artifact
          cp target/release/supervtf artifact/
          # Include QML + media resources (app expects them at runtime)
          cp -r qml media resources.qrc artifact/ || true

          # Compress the binary with UPX (strongest settings)
          upx --best --lzma artifact/supervtf || echo "UPX compression skipped"

          # Create a self-extracting shell script that auto-runs the app
          cd artifact
          tar -cf ../payload.tar *
          cd ..
          # Use pixz for parallel compression (much faster on multi-core runners)
          pixz -9 payload.tar payload.tar.xz

          # Create the self-extracting script (using printf to avoid heredoc issues)
          printf '%s\n' '#!/bin/bash' '# SuperVTF Self-Extracting Launcher' 'TMPDIR=$(mktemp -d /tmp/supervtf.XXXXXX)' 'ARCHIVE_START=$(awk '"'"'/^__ARCHIVE_BELOW__/ {print NR + 1; exit 0; }'"'"' "$0")' 'tail -n+$ARCHIVE_START "$0" | xz -d | tar -xf - -C "$TMPDIR"' 'cd "$TMPDIR"' './supervtf "$@"' 'EXIT_CODE=$?' 'cd /' 'rm -rf "$TMPDIR"' 'exit $EXIT_CODE' '__ARCHIVE_BELOW__' > supervtf-launcher.sh

          # Append the compressed archive to the script
          cat payload.tar.xz >> supervtf-launcher.sh
          chmod +x supervtf-launcher.sh
          mv supervtf-launcher.sh supervtf-linux

      - name: Package (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Install UPX for compression
          choco install upx -y

          $exe = "target\release\supervtf.exe"
          $QtBin = $env:QT_BIN
          if (-not $QtBin -or -not (Test-Path $QtBin)) {
            $qmakePath = (Get-Command qmake.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source) -ne $null ? (Get-Command qmake.exe -ErrorAction SilentlyContinue).Source : $null
            if ($qmakePath) { $QtBin = Split-Path -Path $qmakePath -Parent }
          }
          if (-not (Test-Path $exe)) { throw "Executable not found: $exe" }
          
          # Use windeployqt to gather required Qt DLLs
          $windeploy = (Get-Command windeployqt.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source) -ne $null ? (Get-Command windeployqt.exe -ErrorAction SilentlyContinue).Source : "$QtBin\windeployqt.exe"
          if (-not (Test-Path $windeploy)) { 
            Write-Host "windeployqt not found: $windeploy" 
          } else { 
            # Exclude translations and other extras to save space
            # Added --qmldir qml so windeployqt scans imports and copies QtQuick/Controls modules
            & $windeploy --dir artifact --qmldir qml --no-translations --no-compiler-runtime --no-system-d3d-compiler --no-opengl-sw $exe 
          }
          
          # Copy the main executable
          Copy-Item $exe -Destination artifact
          
          # Remove heavy files if they exist (software rasterizer is often 20MB+)
          if (Test-Path "artifact\opengl32sw.dll") { Remove-Item "artifact\opengl32sw.dll" }
          
          # Compress EXE and DLLs with UPX
          Get-ChildItem artifact -Include *.exe,*.dll -Recurse | ForEach-Object {
            Write-Host "Compressing $($_.Name)..."
            # Added --no-color to avoid parsing issues in some terminals, though not strictly necessary
            upx --best --lzma --force $_.FullName
          }

          # Create SFX (Single Executable)
          $7zPath = "C:\Program Files\7-Zip\7z.exe"
          $sfxModule = "C:\Program Files\7-Zip\7z.sfx"
          
          if (-not (Test-Path $7zPath)) { 
            choco install 7zip -y
            $7zPath = "C:\Program Files\7-Zip\7z.exe"
            $sfxModule = "C:\Program Files\7-Zip\7z.sfx"
          }

          # Create the 7z archive (ULTRA compression)
          & $7zPath a -t7z -m0=lzma2 -mx=9 -mfb=273 -ms=on -md=64m payload.7z ".\artifact\*"
          
          # Create SFX config for SILENT auto-extraction and run
          $configLines = @(
            ';!@Install@!UTF-8!',
            'Title="SuperVTF"',
            'GUIMode="2"',
            'InstallPath="%TEMP%\SuperVTF"',
            'RunProgram="supervtf.exe"',
            ';!@InstallEnd@!'
          )
          $configLines -join "`r`n" | Set-Content -Path config.txt -NoNewline
          
          # Combine to create the single EXE
          cmd /c "copy /b `"$sfxModule`" + config.txt + payload.7z supervtf-portable.exe"

      - name: Upload artifact (Linux)
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: supervtf-linux
          path: supervtf-linux

      - name: Upload artifact (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: supervtf-windows-portable
          path: supervtf-portable.exe